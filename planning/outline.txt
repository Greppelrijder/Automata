The Grid function will be doing most of the work. We need to implement the following features:
! we don't need the general functionality, which will simplify things significantly !
* any amount of possible cell states - this is relatively easy, we represent cells their by state as an integer
* any amount of dimensions - we need to support at least 1d and 2d grids, because both the 1d CA and the 2d CA need to derive from this class. To generalise this properly, any amount of dimensions should be allowed (otherwise we're basically hacking two different child classes into one parent class, which is bad use of OOP)
* any amount of neighbour cells - this will be one of the biggest challanges. Our program needs to be extremely flexible in this regard. For example, in a 1d grid, it should be an option to let each cell have 3 neighbours. This would mean that, for example, the cell to the left and the two cells to the right of a particular cell are considerd its neighbours. On the other hand, 8 neighbours in a 2d-grid would mean: each cell has the ring around it as its neighbours. If we would instead want each cell to have 10 neighbours, then two extra neighbours outside the ring should be assigned. We need to design a neighbour-assigningsystem that is constistant across dimensions
* custom rulesets - this shouldn't be too hard but it won't be trivial either. We'll use the rule system described in the assignment: the neighbourhood of a cell is the integer concatenation of the states of the particular cell and its neighbours. Again, we need to implement a consistant order for this. A 'ruleset' is a map from each possible neighbourhood to the corresponding new state. This way, a ruleset can be represented by a single integer. The system will be further complicated by the fact that more than two states are allowed. Ordering the different neighbourhoods will be more challenging.
* different boundry conditions - we need to implement at least the three boundry rules described in the assignment. This won't be that hard for a specific case like 1d or 2d, but we need to generalize it to any amount of dimensions (probably working with multi-dimensional arrays)


Deriving the CA_1D and CA_2D class should be easy after we designed the Grid class properly

Finally, we need to add some visual functionality to the CA_1D and CA_2D classes. We're not sure what package to use as pygame is not supported currently. However, the visual layer is independend of the inner functionality of the program, so we won't need to worry about this part until later.


--- VISUALISATION ---

* different 'screens' for selection and stuff
* there should always be a button to go back to the main menu


EXECUTION FLOW
* the 'Screen' enum contains the names of all screens that should exist
* each screen has its own file containing a 'run' function that takes:
    > a tkinter root to draw onto
    > an 'args' parameter (of type object) that can contain necessary information to run the screen (e.g. what CA are we drawing?)
* screen_manager keeps track of all existing screens
 - you can register a new screen to screen_manager by specify the name (an item from the 'Screen' enum) and the function (a 'run' function from one of the screen-files)
 - you can run an existing screen by specifying the name (an item form the 'Screen' enum) and passing the tkinter root and the args object. This is how screens should call other screens
 - the main file is responsible for registering all screens to the screen_manager at the start of execution
 

SCREEN HIERARCHY

~ starting screen
    -> main menu: choose different modes
        -> 1D automata prep: choose size, boundry_rules, ruleset
            -> 1D automata simulation: configure starting state; evolve automata (manually or automatically)
        -> 2D automata prepr: choose size, boundry_rules, ruleset
            -> 2D automata simulation: configure starting state; evolve automata (manually or automatically)
        -> Saved creations [optional]: select and run previous automata
    -> settings [optional]: choose coloring etc.




<< starting screen >>

LABELS:
    * [Cellular automata]

BUTTONS:
    * [main menu] -> to 'main menu'
    * [settings] -> to 'settings'
_____________________


<< main menu >>

LABELS:
    * [Main menu]

BUTTONS:
    * [1D cellular automata] -> to '1D cellular prep'
    * [2D cellular automata] -> to '2D cellular prep'
    * [saved creations] -> to 'saved creations'
    * [back] -> to 'starting screen'
_____________________


<< 1D automata prep >>

LABELS:
    * [Creating a brand new 1D cellular automaton]

INPUT:
    * [grid size] : slider
    * [ruleset] : textbox; automatic warning if length is not 8
    * [boundry_conditions] : dropdown menu (Dirichlet0, Dirichlet1, Neumann, Periodic)
    * [creation name]: textbox; must be non-empty

DISPLAY:
    * [grid size preview] : grid with cells; adjusts to <grid size>
    * [ruleset preview] : table; displays the resulting state of each neighbourhood according to the specified ruleset
    * [boundry conditions preview] : icon; demonstrates how the currently selected boundry conditions work 

BUTTONS:
    * [create] -> to '1D simulator'
    * [main menu] -> to 'main menu'
_____________________


<< 1D simulator >>

VARIABLES:
    * [state count] = 0

LABELS:
    * [Simulating <creation name>]
    * [Currently at state <state count>]

INPUT:
    * [grid cells] : grid; when a cell is clicked, it should light up to indicate that it will start ALIVE, click again to cancel
    * [animation FPS] : slider
    * [goto state number] : textbox; should only allow non-negative integers

Display:
    * [grid] : grid - see <grid cells>

BUTTONS:
    * [next step] -> evolve CA and display result; increment <state count>; on first click this should disable INPUT <grid cells>
    * [previous step] -> display CA previous state; decrement <state count> (does nothing if <step count> == 0)
    * [animate] -> evolve & display CA automatically according to <animation FPS>; update <state count> accordingly; this should disable INPUT <animation FPS>
    * [pauze animation] -> stop <animate> and re-enable INPUT <animation FPS>
    * [goto state] -> set CA to state <goto state number> (evolve if necessary); update <state count> accordingly
    * [reset] -> set <state count> to 0; reset CA; re-enable INPUT <grid cells>
    * [save] -> save this creation for later access in 'saved creations' (should check if name has not already been taken)
    * [main menu] -> to 'main menu'
_____________________


<< saved creations >>

LABELS:
    * [Your creations]

DISPLAY:
    * [saved creations] : list

BUTTONS:
    * [goto saved creation] -> to dedicated simulator (one button for each item in <saved creations>)
_____________________


# 2D should work similar to 1D